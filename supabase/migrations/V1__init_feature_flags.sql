-- V1 Initial Migration: Feature Flags Table

-- 1. Create the feature_flags table
CREATE TABLE public.feature_flags (
  id BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  name TEXT NOT NULL UNIQUE,
  is_enabled BOOLEAN DEFAULT FALSE NOT NULL,
  description TEXT,
  created_at TIMESTAMPTZ DEFAULT NOW() NOT NULL,
  updated_at TIMESTAMPTZ DEFAULT NOW() NOT NULL
);

-- Optional: Add a comment to the table
COMMENT ON TABLE public.feature_flags IS 'Stores application feature flags and their statuses.';

-- 2. Enable Row Level Security (RLS)
ALTER TABLE public.feature_flags ENABLE ROW LEVEL SECURITY;

-- 3. Create RLS policies
-- Policy: Allow anonymous read-only access to all feature flags
CREATE POLICY "Allow anon read-only access to feature flags" 
ON public.feature_flags 
FOR SELECT 
TO anon, authenticated 
USING (true);

-- Policy: Disallow public insert, update, delete by default (only service_role can modify)
-- (No explicit policy needed for this, default deny unless allowed)
-- If you need specific roles to manage flags, create policies for them:
-- CREATE POLICY "Allow admin to manage feature flags"
-- ON public.feature_flags
-- FOR ALL
-- TO authenticated -- or a specific role like 'admin'
-- USING (auth.role() = 'admin') -- or check against a user_roles table
-- WITH CHECK (auth.role() = 'admin');

-- 4. Function to update `updated_at` timestamp
CREATE OR REPLACE FUNCTION public.update_updated_at_column()
RETURNS TRIGGER AS $$
BEGIN
  NEW.updated_at = NOW();
  RETURN NEW;
END;
$$ LANGUAGE plpgsql;

-- 5. Trigger to update `updated_at` on row modification
CREATE TRIGGER handle_feature_flags_updated_at
BEFORE UPDATE ON public.feature_flags
FOR EACH ROW
EXECUTE FUNCTION public.update_updated_at_column(); 